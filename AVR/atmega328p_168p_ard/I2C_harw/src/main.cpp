#define __AVR_ATmega168__
#define F_CPU 16000000UL  // Частота тактирования микроконтроллера
#define TWI_FREQ 100000UL  // Желаемая частота I2C

//TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;

#include <avr/io.h>
#include <avr/interrupt.h>

#include <oled_RVV.h>


/*################_____________MASTER________############################################################*/
#ifndef I2C_HEAD_MASTER
#define I2C_HEAD_MASTER
void TWI_InitMaster(unsigned long FREQ_I2C);

void TWI_Start(void);
void TWI_Stop(void);
void TWI_Write(unsigned char data);

/*----------------------------------------------------------------*/
/* TWI_Read_ACK: Используется, когда нужно прочитать несколько байт данных подряд. 
После чтения каждого байта отправляется подтверждение (ACK), 
чтобы ведомое устройство продолжало передачу следующего байта.*/

unsigned char TWI_Read_ACK(void);
/*------------------------------------------------------------------*/


/*----------------------------------------------------------------*/
/* TWI_Read_NACK: Используется для чтения последнего байта данных. 
После чтения последнего байта отправляется отсутствие подтверждения (NACK), 
чтобы указать ведомому устройству,что передача данных завершена.*/

unsigned char TWI_Read_NACK(void);
/*------------------------------------------------------------------*/

#endif
/*###########################################################################################################################################*/



/*################_____________SLAVE________############################################################*/
#ifndef I2C_HEAD_SLAVE
#define I2C_HEAD_SLAVE
/*----------------------------------------------------------------*/
/* Для настройки микроконтроллера Atmega168p на работу в режиме slave (ведомого) 
по протоколу I2C (TWI), нужно выполнить несколько шагов. 
В режиме slave микроконтроллер будет реагировать на запросы от master (ведущего) устройства.
Настройка адреса устройства:

Установите адрес устройства в регистре TWAR (TWI (Slave) Address Register).
Настройка прерываний:

Включите прерывания для обработки запросов от master устройства.
Обработка прерываний:

Напишите обработчик прерываний для чтения и записи данных.*/

/*------------------------------------------------------------------*/
#define SLAVE_ADDRESS 0x20  // Адрес slave устройства

volatile unsigned char receivedData;

/*
Пример: мастер отправляет 2 байта (цифры), ведомый отправляет число из цифр
*/
volatile unsigned char receivedByte[2];
volatile unsigned char dataIndex = 0;
volatile unsigned char result;

void TWI_InitSlave();

ISR(TWI_vect);

#endif
/*###########################################################################################################################################*/






int main(void) {
    
    /*------------------- Пример передачи данных-------------------*/
    /*
    TWI_InitMaster(TWI_FREQ);
    TWI_Start();
    TWI_Write(0x20);  // Адрес устройства
    TWI_Write(0x34);  // Данные для передачи
    TWI_Stop();
    */
    /*-------------------------------------------------------------*/

    /*------------------- Пример приема данных-------------------*/
    /*
    TWI_InitMaster(TWI_FREQ);
    TWI_Start();
    TWI_Write(0x20 | 1);  // Адрес устройства для чтения
    uint8_t data = TWI_Read_NACK();  // Чтение данных
    TWI_Stop();
    */
    /*-------------------------------------------------------------*/
    
  I2C_Init(FREQ_DATA_I2C);
  SSD1306_Init();
  SSD1306_Clear();

  // SSD1306_DisplayByte(63, 32, 0x01);
  SSD1306_SetPixel(63, 32, ON_PIX);
  
    while (1) {
        // Основной цикл
    }
}

void TWI_InitMaster(unsigned long FREQ_I2C){
  // Настройка частоты I2C
    TWBR = ((F_CPU / FREQ_I2C) - 16) / 2;
    TWSR = 0;

    // Включение I2C
    /*
    TWEN: бит разрешения TWI
    Бит TWEN разрешает работу TWI и активирует интерфейс TWI. Когда в TWEN записывается единица, TWI получает управление
    над выводами ввода/вывода, подключенными к выводам SCL и SDA, включая ограничители скорости нарастания и фильтры спайков. Если этот бит записан в
    ноль, TWI выключается и все передачи TWI прекращаются, независимо от текущих операций.
    */
    TWCR = (1 << TWEN);
    return;
}


void TWI_Start(void) {
    /*TWI Control Register;

    TWSTA: бит состояния запуска TWI
    Приложение записывает бит TWSTA в единицу, когда хочет стать ведущим на 2-проводной последовательной шине. Аппаратное обеспечение TWI
    проверяет, свободна ли шина, и генерирует условие START на шине, если она свободна. Однако если шина не свободна, то
    TWI ждет, пока не будет обнаружено состояние STOP, а затем генерирует новое состояние START, чтобы заявить о своем статусе ведущего устройства шины.
    TWSTA должен быть очищен программно после передачи условия START.
    
    TWINT: Флаг прерывания TWI
    Этот бит устанавливается аппаратно, когда TWI завершает свою текущую работу и ожидает ответа прикладного программного обеспечения. Если бит I в
    SREG и TWIE в TWCR установлены, MCU переходит к вектору прерывания TWI. Пока флаг TWINT установлен, период низкого уровня SCL
    растягивается. Флаг TWINT должен быть сброшен программно путем записи в него логической единицы. Обратите внимание, что этот флаг не
    автоматически не снимается аппаратными средствами при выполнении процедуры прерывания. Также обратите внимание, что сброс этого флага запускает работу
    TWI, поэтому все обращения к регистру адреса TWI (TWAR), регистру состояния TWI (TWSR) и регистру данных TWI (TWDR) должны быть завершены до сброса этого флага.
     */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    while (!(TWCR & (1 << TWINT)))
    ;
    return;
}

void TWI_Stop(void) {
    /*TWI Control Register;

    TWSTO: бит условия STOP TWI
    Запись бита TWSTO в единицу в режиме ведущего устройства генерирует состояние STOP на 2-проводной последовательной шине. Когда условие STOP
    на шине, бит TWSTO автоматически очищается. В режиме ведомого устройства установка бита TWSTO может быть использована
    для восстановления после ошибки. При этом не генерируется условие STOP, но TWI возвращается в четко определенное состояние.
    безадресный режим Slave и переводит линии SCL и SDA в высокоимпедансное состояние.
    
    TWINT: Флаг прерывания TWI
    Этот бит устанавливается аппаратно, когда TWI завершает свою текущую работу и ожидает ответа прикладного программного обеспечения. Если бит I в
    SREG и TWIE в TWCR установлены, MCU переходит к вектору прерывания TWI. Пока флаг TWINT установлен, период низкого уровня SCL
    растягивается. Флаг TWINT должен быть сброшен программно путем записи в него логической единицы. Обратите внимание, что этот флаг не
    автоматически не снимается аппаратными средствами при выполнении процедуры прерывания. Также обратите внимание, что сброс этого флага запускает работу
    TWI, поэтому все обращения к регистру адреса TWI (TWAR), регистру состояния TWI (TWSR) и регистру данных TWI (TWDR) должны быть завершены до сброса этого флага.
     */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    return;
}

void TWI_Write(unsigned char data) {
    TWDR = data;
    TWCR = (1 << TWINT) | (1 << TWEN);
    while (!(TWCR & (1 << TWINT)))
    ;
    return;
}


unsigned char TWI_Read_ACK(void) {
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    while (!(TWCR & (1 << TWINT)));
    return TWDR;
}

unsigned char TWI_Read_NACK(void) {
    TWCR = (1 << TWINT) | (1 << TWEN);
    while (!(TWCR & (1 << TWINT)));
    return TWDR;
}
/*#####################################################*/


void TWI_InitSlave(){
  // Настройка адреса slave устройства
  TWAR = (SLAVE_ADDRESS << 1);

  // Включение I2C и прерываний
  TWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWEA);

  // Включение глобальных прерываний
  sei();
}

ISR(TWI_vect){
  //state register
  switch (TWSR & 0xF8){ // Маскируем младшие 3 бита, так как они не используются
    
    // Адрес + чтение (master хочет прочитать данные)
    case 0x60:
      //TWDR = receivedData;  // Подготовить данные для передачи
      
      /*____*/
      TWDR = result;  // Подготовить данные для передачи
      /*____*/

      TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
      break;

    // Адрес + запись (master хочет записать данные)
    case 0xA8:
      TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
      break;

    // Данные + ACK (master записал данные и ожидает следующий байт)
    case 0x80:
      // receivedData = TWDR;  // Сохранить полученные данные
      
      /*____*/
      if (dataIndex < 2)
        receivedByte[dataIndex++] = TWDR;  // Сохранить полученные данные
      /*____*/
      
      TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
      break;

    // Данные + NACK (master завершил запись данных)
    case 0x88:
      //receivedData = TWDR;  // Сохранить полученные данные
      
      /*____*/
      if (dataIndex < 2)
        receivedByte[dataIndex++] = TWDR;  // Сохранить полученные данные
      result = (receivedByte[0] - '0') * 10 + (receivedByte[1] - '0');
      /*____*/
      
      TWCR = (1 << TWINT) | (1 << TWEN);
      break;

    // Данные + ACK (master прочитал данные и ожидает следующий байт)
    case 0xB8:
      TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
      break;

    // Данные + NACK (master завершил чтение данных)
    case 0xC0:
      TWCR = (1 << TWINT) | (1 << TWEN);
      break;

    default:
      TWCR = (1 << TWINT) | (1 << TWEN);
      break;
    
  }
}